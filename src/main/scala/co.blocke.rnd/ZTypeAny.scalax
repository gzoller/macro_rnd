package co.blocke.scala_reflection

import scala.quoted.*
import quoted.Quotes

import java.io.*
import java.nio.ByteBuffer
import java.nio.file.{Files, Path}
import co.blocke.scala_reflection.RType
import co.blocke.scala_reflection.info.*
import co.blocke.scala_reflection.impl.*
import scala.jdk.CollectionConverters.*

object ZTypeAny:

  /** Default implementation of `ToExpr[BigInt]` */
  given StringBuilderToExpr: ToExpr[StringBuilder] with {
    def apply(x: StringBuilder)(using Quotes): Expr[StringBuilder] =
      '{ new StringBuilder( { ${Expr(x.toString)} } ) }
  }

  given ToExpr[Any] with {                               
    def apply(x: Any)(using Quotes) = {
      import quotes.reflect._
      Ref(defn.AnyClass).appliedToType(TypeRepr.typeConstructorOf(x.getClass)).asExpr.asInstanceOf[Expr[Any]]
    }
  }

  inline def toJson[T](t: T): String = ${ toJsonImpl[T]('t, '{RType.of[T]}) }

  def toJsonImpl[T:Type](t: Expr[T], r: Expr[RType])(using quotes:Quotes): Expr[String] = {
    import quotes.reflect.* 

    println("HEY In compiler!")

    // Given some value, render the Json string
    // def renderJsonFn[T:Type](rt: RType): Expr[(T,StringBuilder) => StringBuilder] = 
    def renderJsonFn(rt: RType): Expr[(Any,StringBuilder) => StringBuilder] = 
      rt match {
        case PrimitiveType.Scala_String => 
          '{(a:Any, sb:StringBuilder) =>
            sb.append('"')
            sb.append(a.toString)
            sb.append('"')
          }

          /*
          Plan:
            1. Get sb passed down into ${}
            2. $sb.append(scalaField.name+":")
            3. Make recursive call to fn(fieldValue, $sb)
          */
        case classInfo: ClassInfo =>
          val ciExp = Expr(rt)
          val fieldFns = classInfo.fields.toList.map( f => renderJsonFn(f.fieldType) )
          val zipped = fieldFns.zip(classInfo.fields)

          '{(a:Any, sb:StringBuilder) => 
            sb.append('{')
            val stuff = ${
             val statements = zipped.map{ case (fn, field) => 
                val scalaField = field.asInstanceOf[ScalaFieldInfo]
                val typeMaker = field.fieldType.toType
                val fieldType = typeMaker(quotes).asType
                '{ 
                  sb.append(${Expr(field.name)})
                  sb.append(':')
                  val fieldValue = ${ 
                    val foo = '{a}.asTerm.tpe
                    println("FOO: "+foo)
                    // val foo = '{a}.asTerm.asExprOf(using fieldType)
                    Select.unique('{ a }.asTerm, scalaField.name).asExpr 
                    // Select.unique('{ a }.asTerm, scalaField.name).asExprOf(using fieldType2)
                  }
                  $fn(fieldValue, sb)
                  // sb.append(fieldValue.toString)
                  sb.append(',')
                }
              }
              Expr.ofList(statements)
              // Block(statements.init, statements.last) // blocks may not be empty, and take a list of statements, followed by a final expression, I looked up the API
            }
            sb.setCharAt(sb.length()-1,'}')
          }

        case _ =>
          '{(a:Any, sb:StringBuilder) => 
            sb.append(a.toString)
          }
      }

    val renderMe = renderJsonFn(RType.unwindType(quotes)(TypeRepr.of[T]))
    val sb = Expr(new StringBuilder())
    '{ 
      // val s = scala.Symbol($t.getClass.getName)
      // import scala.quoted.*
      // given Quotes = s.asQuotes
      $renderMe($t, $sb).toString 
    }
  }

  /*

  object RenderWell:
    def getRenderFor[T:Type](rt: RType)(theType: T): RenderMaker[T] = ???

  abstract class RenderMaker[T:Type]( rtype: RType )(using quotes:Quotes) {
    def makeRenderFn(): Expr[ (T,StringBuilder) => StringBuilder ]
  }

  class StringRenderMaker()(using quotes:Quotes) extends RenderMaker[String](PrimitiveType.Scala_String):
    def makeRenderFn(): Expr[ (String,StringBuilder) => StringBuilder ] =
      '{(a:String, sb:StringBuilder) =>
        sb.append('"')
        sb.append(a.toString)
        sb.append('"')
      }

  class ClassRenderMaker[T:Type](rt: RType)(using quotes:Quotes) extends RenderMaker[T](rt):
    import quotes.reflect.*
    def makeRenderFn(): Expr[ (T,StringBuilder) => StringBuilder ] =
      val fieldRenderMakers = rt.asInstanceOf[ClassInfo].fields.toList.map{ f => 
        val typeMaker = f.fieldType.toType
        val fieldType = typeMaker(quotes).asType
        RenderWell.getRenderFor(f.fieldType)(fieldType)
      }
      val zipped = fieldRenderMakers.zip(rt.asInstanceOf[ClassInfo].fields)
      '{(a:T, sb:StringBuilder) =>
        sb.append('{')
        val stuff = ${
          val statements = zipped.map{ case (fn, field) => 
            '{ 
              sb.append(${Expr(field.name)})
              sb.append(':')
              val fieldValue = ${ Select.unique('{ a }.asTerm, field.name).asExpr }.asInstanceOf[T]
              ${fn.makeRenderFn()}(fieldValue, sb)
              sb.append(',')
            }
          }
          Expr.ofList(statements)
        }
        sb.setCharAt(sb.length()-1,'}')
      }

          '{(a:T, sb:StringBuilder) => 
            sb.append('{')
            val stuff = ${
             val statements = zipped.map{ case (fn, field) => 
                val scalaField = field.asInstanceOf[ScalaFieldInfo]
                val fieldType1 = field.fieldType.toType
                val fieldType2 = fieldType1(quotes).asType
                '{ 
                  sb.append(${Expr(field.name)})
                  sb.append(':')
                  val fieldValue = ${ 
                    val tt = Type.of[Int]
                    // val zz = fieldType2
                    Select.unique('{ a }.asTerm, scalaField.name).asExpr 
                    Select.unique('{ a }.asTerm, scalaField.name).asExprOf(using fieldType2)
                  }
                  $fn(fieldValue, sb)
                  // sb.append(fieldValue.toString)
                  sb.append(',')
                }
              }
              Expr.ofList(statements)
              // Block(statements.init, statements.last) // blocks may not be empty, and take a list of statements, followed by a final expression, I looked up the API
            }
            sb.setCharAt(sb.length()-1,'}')
          }
*/